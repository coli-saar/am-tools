interpretation string: de.up.ling.irtg.algebra.StringAlgebra
interpretation graph: de.up.ling.irtg.algebra.graph.ApplyModifyGraphAlgebra


F! -> SubjCtrlSent(SubjCtrl, Open_S_to, Subj) [0.9]
[string] *(*(?3, *(?1, ?2)), '.')
[graph] APP_subj(APP_obj(?1, ?2), ?3)

// ------------------------------- TP with PRO subject ------------------------------------------

Open_S_to -> TP_PRO(Open_S_inf) [0.4]
[string] *(to, ?1)
[graph] ?1

// recursive rule for nested subject control
Open_S_inf -> VbarSubjCtrl(SubjCtrl, Open_S_to) [0.2]
[string] *(?1, ?2)
[graph]  APP_obj(?1, ?2)

Open_S_inf -> sleep [0.05]
[string] sleep
[graph] '(r<root> / sleep-01 :ARG0 (s<subj>))--TYPE--(subj())'

Open_S_inf -> Coord_Open_S_inf(And_Open_S, Open_S_inf, Open_S_inf) [10]
[string] *(?2, *(?1, ?3))
[graph] APP_op1(APP_op2(?1, ?3), ?2)

And_Open_S -> and_open_s [1.0]
[string] and
[graph] '(r<root> / and :op1 (op1<op1>) :op2 (op2<op2>))--TYPE--(op1(subj()), op2(subj()))'

SubjCtrl -> try [0.1]
[string] try
[graph] '(r<root> / try-01 :ARG0 (s<subj>) :ARG1 (o<obj>))--TYPE--(subj(), obj(subj))'

SubjCtrl -> want [0.1]
[string] want
[graph] '(r<root> / want-01 :ARG0 (s<subj>) :ARG1 (o<obj>))--TYPE--(subj(), obj(subj))'

SubjCtrl -> hate [0.1]
[string] hate
[graph] '(r<root> / hate-01 :ARG0 (s<subj>) :ARG1 (o<obj>))--TYPE--(subj(), obj(subj))'

// -------------------------------- subjects -------------------------------------------------
// 1st and 2nd person only

Subj -> I [0.33]
[string] I
[graph] '(r<root> / i)--TYPE--()'

Subj -> we [0.33]
[string] We
[graph] '(r<root> / we)--TYPE--()'

Subj -> you [0.34]
[string] You
[graph] '(r<root> / you)--TYPE--()'
